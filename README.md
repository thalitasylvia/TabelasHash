# TabelasHash

Se você quiser entender o que é uma Tabela Hash, como essa estrutura de dados funciona e qual a vantagem de utilizá-la, pode ser uma boa ideia ler a documentação e depurar esse projeto. Trata-se de uma trabalho prático para a disciplina de AED que insere alguns dados de todos os estados brasileiros em uma tabela hash utilizando nome de cada estado como chave.

Documentação AED – Trabalho Prático II Izabela Andrade, Thalita Marques Curso de Bacharelado em Sistemas de Informação – Pontifícia Universidade Católica de Minas Gerais (PUC Minas) – Campus de Contagem 32265-450 – Contagem – MG– Brasil Introdução: A proposta do presente trabalho consiste em desenvolver um programa em C# que implemente a Estrutura de Dados Tabela Hash. A estrutura será usada para armazenar registros de todos os estados brasileiros de forma que facilite, posteriormente, a busca desses elementos, visto que com uma boa função hash pode-se evitar comparações que não encontram o elemento procurado. À estas comparações dá-se o nome de “colisões”. Uma Tabela Hash bem elaborada tem tamanho e função hash estratégicas e assim contribui para algoritmos de busca e inserção que custem menos, principalmente em questão de tempo. O sucesso da implementação é então o equilíbrio entre os gastos de tempo das execuções e o espaço da memória.

Funcionamento: Definido pela proposta de implementação, o usuário deve escolher, em tempo de execução, qual será o tamanho da Tabela Hash a ser criada, bem como o tipo de Tratamento de Colisões utilizado: Lista Encadeada ou Endereçamento Aberto. Não lhe é permitido informar um número negativo ou nulo para o tamanho da tabela, no caso do Endereçamento Aberto inclusive, não lhe é permitido criar uma tabela menor que o número de estados no Brasil (27), pois, já que conhecemos previamente as chaves a serem inseridas, podemos fazer uso deste controle tão útil. Os elementos são formados por dados de entrada vindos de um arquivo de texto chamado estados.txt logo após o usuário fornecer informações para a criação da tabela. Então o usuário tem a oportunidade de pesquisar por quantos estados quiser, sendo informado do número de colisões a cada busca por uma nova chave. Definido pela programação, inserção e busca têm mesmo número de colisões. O usuário também pode visualizar na tela como está a tabela e as posições em que se encontram cada chave (estado) ao final das pesquisas.

Elementos e Chaves: Os elementos a serem inseridos na Tabela Hash são instâncias da classe Estado. A classe representa um estado do Brasil tendo como atributos seu nome (string), capital (string), região (string) e quantidade de municípios (int). Além desses campos, a classe conta também com o método construtor, que recebe os dados como parâmetros para inicializa-los e com o método imprime, que mostra na tela o conteúdo desses campos. O campo nome do estado é considerado a chave, que através do método função hash, tem sempre uma posição específica para endereçamento de todo o elemento (instância de estado) na Tabela Hash.

Estruturas de Dados: No caso do usuário escolher Listas Encadeadas para tratar colisões, criamos a tabela hash como um vetor de listas encadeadas. Já no caso de Endereçamento Aberto, utilizamos apenas um vetor de objetos do tipo Estado. Porém, para que este último funcione corretamente, precisa ter mais posições do que o primeiro.

Herança: Como o tipo de Tratamento de Colisões altera totalmente a forma como a Tabela Hash funciona, precisaríamos de duas classes de Tabela Hash diferentes. Porém elas não deixariam de ter muito em comum, por isso resolvemos usar Herança, o que reduziu consideravelmente o código além de tê-lo deixado bem mais modularizado e sem redundâncias. Criamos uma Classe Abstrata Hash contendo o atributo (int)tamanho e o método funcaoHash(), já que estes seriam iguais para as duas situações possíveis, e os métodos que seriam diferentes tiveram apenas suas assinaturas definidas e foram declarados como abstratos, assim como a classe. A maior vantagem da herança foi poder declarar a tabela como sendo do tipo Hash, e depois poderia ser atribuída a ela tanto uma instância de HashLE quanto de HashEA.

Função Hash: Tanto para inserir quanto para buscar por um elemento/chave na tabela Hash é utilizado uma função que retorna uma posição ou endereço na tabela. Essa função é definida pelo programador e neste trabalho escolhemos multiplicar a posição alfabética de cada letra da chave, sendo esta do tipo string (nome do estado), pela posição da letra dentro da própria string. Para cada caractere na string, repetimos o procedimento somando e acumulando essa soma. No final da função hash retornamos o módulo da soma com o tamanho da tabela. Esse retorno é usado como posição da tabela. O método pertence à classe abstrata citada acima.

HashLE: Como citado, a classe HashLE é filha da classe abstrata Hash e implementa alguns métodos abstratos de maneira particular. São estes: insereNaTabela(Estado estado), procuraEstado(string nome) e imprimir().

HashEA: A classe HashEA, assim como a anterior, também é filha da classe abstrata Hash e implementa os mesmos métodos abstratos de maneira particular.

Classes Lista e Node: A classe Lista é o modelo da Estrutura de Dados de Lista Encadeada utilizada para armazenar as chaves de mesmo resultado de função hash, ou seja, chaves que colidiram no memento de inserção (no caso do Tratamento de Colisões ser por Listas Encadeadas). A classe conta com três métodos, sendo eles o construtor, o vazia (verifica se a lista já tem elementos inseridos) e o insereFim (que recebe uma instância de estado e o insere no fim da lista). A classe Node é o modelo de cada nó na estrutura de Lista Encadeada. Cada nó não nulo guarda uma instância de um estado e um ponteiro para o próximo nó. De método, conta apenas com o seu construtor.

Classe Program: Na Classe Program temos dois métodos sendo utilizados, buscarDados e o Main, onde começa a execução do programa. 10.1. levarDados() O método leverDados deixamos comentado no código, pois não é usado durante a execução, mas o chamamos uma vez para criar um arquivo de texto com os dados retirados da internet. 10.2. buscarDados(Hash tabela) O método buscarDados recebe como parâmetro uma Tabela Hash qualquer, onde vai depositar os dados. O arquivo então é lido linha a linha, inicializando uma nova instância de Estado com os dados da linha, e já insere na tabela (parâmetro) o estado (objeto criado). O método a ser usado para inserir na tabela vai depender de que tipo de tabela ela é, HashLE ou HashEA. Porém a execução sabe qual chamar sem que precisemos nos preocupar com isso, graças à Herança na Orientação a Objetos. 10.3. Main No método Main temos as entradas do usuário de tipo de Tratamento de Colisões e Tamanho da tabela sendo inseridas e validadas. O tamanho precisa ser um número positivo, sendo que se o Tratamento de Colisões for por Endereçamento Aberto, o tamanho precisa ser maior do que o número total e chaves, que é 27 (estados do Brasil). A variável tabelaHash é declarada logo no início. Sendo do tipo Hash, pode receber uma instância tanto de HashLE quanto de HashEA. Depois de criada a tabela, o usuário pode pesquisar quantos estados desejar até responder “S” quando for perguntado se deseja sair. O usuário é informado do número de colisões na busca da chave. Após sair da pesquisa de chaves, há a possibilidade de visualizar todos os elementos na tabela hash assim como estão dispostos na mesma. Essa visualização ocorre através do método abstrato imprimir, implementado nas filhas da classe Hash.

Testes: Os testes foram divididos de acordo com as duas possibilidades de tratamento de colisões: com Listas Encadeadas e com Endereçamento Aberto, já que os algoritmos seriam diferentes de um tipo de tratamento para outro. No pdf da documentação é encontrado prints dos principais testes. Para todos os testes, as chaves foram inseridas em ordem alfabética, que era a ordem em que estavam dispostas no arquivo de texto de entrada. A cada linha lida do arquivo de texto era instanciado um estado que era inserido na Tabela Hash utilizando seu nome como chave. 11.1. Com Listas Encadeadas O usuário pode pesquisar por quantas chaves desejar e, posteriormente, pode visualizar como estava a tabela hash (apenas para que entenda melhor seu funcionamento, mesmo durante a execução). Veja no documento, testes de criação da tabela com validação do tamanho escolhido, que deve ser maior que 0 (zero); teste de busca por chaves mostrando número de colisões em cada busca ou mensagem informando caso a chave não exista na tabela; teste de visualização da tabela. Foi criada tabela de tamanho 11. 11.2. Com Endereçamento Aberto Da mesma maneira, o usuário pode pesquisar por quantas chaves desejar e, posteriormente, pode visualizar como estava a tabela hash (apenas para que entenda melhor seu funcionamento, mesmo durante a execução). Na documentação, imagens de testes de criação da tabela com validação do tamanho escolhido, que deve ser maior que a tabela hash para que comporte todos os elementos; teste de busca por chaves mostrando número de colisões em cada busca ou mensagem informando caso a chave não exista na tabela; teste de visualização da tabela bem como o valor da função hash para cada chave, apenas para que se facilite o entendimento das colisões. Foi criada tabela de tamanho 31.

Conclusão: Com a implementação deste trabalho foi possível entendermos, principalmente por meio dos testes, como o tamanho da Tabela Hash, a elaboração da função hash e a ordem em que são inseridos os elementos podem influenciar diretamente no número de colisões e consequentemente na complexidade dos algoritmos de inserção e busca de elementos por meio de suas chaves. Também percebemos que conhecer as chaves é fundamental para construir uma Estrutura de Dados Tabela Hash. Sendo assim, cada problema que demanda um programa utilizando uma estrutura dessas para sua solução, demanda consequentemente uma Tabela Hash específica.
